# encoding: utf-8

##
# Oedipus Sphinx 2 Search.
# Copyright Â© 2012 Chris Corbyn.
#
# See LICENSE file for details.
##

module Oedipus
  # Mixed into RSpec suites to manage starting/stopping Sphinx.
  module TestHarness
    # Set the path to the searchd executable.
    #
    # The version of Sphinx must be >= 2.0.2.
    #
    # @param [String] path
    #   the absolute path to searchd
    def set_searchd(path)
      @searchd = path
    end

    # Set the path to a temporary directory for writing test data to.
    #
    # @param [String] path
    #   the path to a writable directory whose contents may be completely deleted
    def set_data_dir(path)
      @data_dir = path
    end

    # Ensure that the temporary data directories exist and are clean.
    def prepare_data_dirs
      Dir.mkdir("#{data_dir}/index")  unless Dir.exist?("#{data_dir}/index")
      Dir.mkdir("#{data_dir}/binlog") unless Dir.exist?("#{data_dir}/binlog")

      clean_data_dirs
    end

    def empty_indexes
      require "mysql"
      @conn ||= ::Mysql.new(searchd_host[:host], nil, nil, nil, searchd_host[:port])

      idxs = @conn.query("SHOW TABLES")

      while idx = idxs.fetch_hash
        docs = @conn.query("SELECT id FROM #{idx['Index']}")
        while hash = docs.fetch_hash
          @conn.query("DELETE FROM #{idx['Index']} WHERE id = #{hash['id']}")
        end
      end
    end

    # Write the sphinx.conf file, using #index_definiton.
    #
    # Sphinx will listen on localhost port 9399.
    #
    # Any string returned from #index_definition will be used to define one or more indexes.
    def write_sphinx_conf
      File.open(searchd_config, "wb") do |f|
        f <<
        <<-CONF.gsub(/^ {10}/m, "")
          ##
          # This file is automatically generated during tests
          ##

          #{index_definition}

          searchd
          {
            compat_sphinxql_magics = 0

            max_matches  = 2000
            pid_file     = #{data_dir}/searchd.pid
            listen       = #{searchd_host[:host]}:#{searchd_host[:port]}:mysql41
            workers      = threads
            log          = #{data_dir}/searchd.log
            binlog_path  = #{data_dir}/binlog
          }
        CONF
      end
    end

    # Start the sphinx daemon in a child process and return the PID.
    #
    # Output is redirected to searchd.out and searchd.err in the data dir.
    def start_searchd
      @searchd_pid = Process.spawn(
        searchd, "--console", "-c", searchd_config,
        out: "#{data_dir}/searchd.out",
        err: "#{data_dir}/searchd.err"
      )
      sleep 1
    end

    # Stop an already running sphinx daemon and wait for it to shutdown.
    def stop_searchd
      Process.kill("TERM", @searchd_pid) && Process.wait
    end

    private

    def clean_data_dirs
      clean_files("#{data_dir}/index/**/*")
      clean_files("#{data_dir}/binlog/**/*")
      clean_files("#{data_dir}/searchd.pid")
      clean_files("#{data_dir}/searchd.out")
      clean_files("#{data_dir}/searchd.err")
      clean_files("#{data_dir}/sphinx.conf")
    end

    def searchd_host
      { host: "127.0.0.1", port: 9399 }
    end

    # May be overridden in specs with a #let block.
    #
    # It is important to set the index path to file in data_dir/index/ in order to ensure correct teardown.
    def index_definition
      <<-INDEX.gsub(/^ {10}/m, "")
        index posts_rt
        {
          type = rt
          path = #{data_dir}/index/posts_rt

          rt_field       = title
          rt_field       = body

          rt_attr_uint   = user_id
          rt_attr_uint   = views
          rt_attr_string = status
        }
      INDEX
    end

    def searchd
      @searchd ||= "searchd"
    end

    def searchd_config
      "#{data_dir}/sphinx.conf"
    end

    def clean_files(path)
      Dir[path].each { |f| File.delete(f) unless File.directory?(f) }
    end

    def data_dir
      @data_dir ||= "./data"
    end
  end
end
